
1. memory
2. 类加载机制

class载入 加载->验证->准备->解析->初始化->使用->卸载

加载的时机是？
1. new(new 一个对象), getStatic(读取一个静态字段),putStatic(设置一个静态字段，被final修饰的静态变量在编译时已经在常量池的静态字段),invokestatic(调用静态方法) -> 没有初始化，则需要先进行初始化
2. 使用反射

---
被动使用并不会引起加载动作：
1. 通过子类访问父类的静态变量 SubClassName.parentStaticField
2. 常量访问(常量在编译器完成初始化)
3. 定义数组(new Hello[] 并不会引起初始化。有什么特殊？）
数组创建有什么特殊？
数组类的创建不是通过类加载器，由JVM直接创建

加载过程->
1. 加载二进制流
2. 将静态存储结构转化为方法区的运行时数据结构（方法区，一个类中所有的部分都被定义为opp-class模型）
3. 在内存里生成一个java.lang.Class对象

验证->
1. 格式, COFFEEBABY
2. 元数据验证。 是否有父类，是否继承了final类(不合法)，抽象类与非抽象类，继承的重载/重写问题
3. 字节码验证。类型load，跳转指令，类型转换
4. 符号引用验证。符号引用转化成直接引用

准备阶段 ->
1. 为类变量分配内存并设置初始值的阶段(默认值 int -> 0, boolean -> false,reference -> null) -> 放在方法区中
2. 如果class文件中的表存在ConstantValue属性，则会被初始化为ConstantValue的值

解析 ->(没有强制解析发生的时间，只有说明在使用之前)

符号引用 -> 直接引用的过程
1. 对同一个符号的多次解析->除了invokedynamic之外，对第一次解析结果缓存(在运行时常量池纪录直接引用，然后标记常量为解析状态)

初始化->

clinit 
1. 编译器自动收集类中的所有类变量的赋值动作 + static block。 顺序是源码中定义的顺序
2. 不是一定会生成(只有在有static域的时候)
3. 接口中有static的变量赋值动作，也会生成clinit
4. 父类的clinit方法先执行。 
5. 虚拟机可以保证在并发环境下clinit的同步。多个线程去执行，仅有1个线程执行clinit。这个过程会隐含阻塞

----------

类加载器：

类层次划分
OSGi
热部署
代码加密

任何一个类 由 类加载器+这个类本身来确定Java虚拟机的唯一性
每一个类加载器，都有1个独立的类名称空间













3. 并发部分