1. 单一职责(Sinple Responsibility Principle SRP):应该仅有一个原因引起类的变更
    -> 职责：什么是职责？如何划分一个类地职责？什么样的职责是单一？过于考虑单一职责引起的耦合过重问题(需要通过组合来实现合作)
    -> 适用于接口，类上
        changeUser -> no no 
        changeUserName, changeHomeAddress,changeOfficeTel 每个方法职责清晰，维护方便
    -> 最佳实践: 接口设计单一职责，类的设计仅有一个原因引起变化

2. 里氏替换原则(Liskov Subsitution Principle, LSP):所有引起基类的地方必须能透明地使用其子类地对象
    -> 继承的设计实现方法知道原则
    -> 1. 子类必须完全实现父类的方法
    -> 2. 子类可以有自己的个性(子类有自己的行为和外观)
    -> 3. 覆盖或实现父类的方法时输入参数可以被放大。例如 Map -> HashMap (重载<同一个类中相同方法名称，不同参数类型>，重写<与父类拥有相同的方法签名>) -> 违背这条规则会是什么情况(输入的参数被缩小了，父类出现的地方，子类未必可以出现)？
    -> 4. 覆写或实现父类的方法时输出结果可以被缩小。例如 return Map -> return HashMap

3. 依赖倒置原则(Dependence Inversion Principle，DIP):高层模块不依赖底层模块，两者都以来其抽象；抽象不依赖细节；细节依赖抽象。
    -> 抽象：接口，抽象类
    -> 细节：实现类
    -> 模块间依赖通过抽象发生，实现类之前不发生直接的依赖关系，其依赖关系时通过接口或抽象产生的；接口或抽象类不依赖实现类；实现类依赖接口或抽象类
    -> 可以理解为面向接口编程
    -> 减少类间的耦合性，提高稳定性，降低并行开发的风险，提高可读性和可维护性
        -> 稳定性：什么是稳定的？固话的，健壮的。在周围环境频繁变化的时候，依然可以做到不变性
        -> 减少并行开发引起的风险。什么是并行开发引起的风险？风险扩散：一段程序的错误或异常，逐步波及一个功能，一个模块，甚至到整个项目
        -> 耦合性：模块间的合作关系，依赖(依赖的实现方式)。如果做到抽象依赖，那么出现多层传递也无所畏惧
            -> 构造函数传递对象(构造函数注入)；Setter；接口声明依赖

4. 接口隔离原则:依赖最小接口，不依赖它不需要的接口
5. 迪米特法则(Law Of Demeter, LoD)，最少知识原则：


