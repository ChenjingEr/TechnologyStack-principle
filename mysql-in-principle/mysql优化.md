## mysql 优化

##### schema 优化

* 选择优化的数据类型
    
    1. 选择适用的最小的数据类型。更小的数据类型存储的空间更小，处理时需要的CPU周期也更少。
    2. 简单就好
    3. 避免NULL。查询的列中有NULL值，更加难以优化。2

##### 索引优化

* 索引优化
    - 独立的列：即在索引列上不做计算
    - 前缀索引：长字符串的优化
    - 多列索引:使用索引列的顺序/排序优化/最左匹配
    - 聚簇索引
    - 覆盖索引

##### 查询优化

查询优化考虑的点：1. 是否有额外的操作。2. 是否有重复的额外的操作。3. 耗时操作 <br>
慢查询可能出现的原因：

1. 访问过量数据
    1. case 1
    
        描述：在服务端检索大量数据然后在客户端丢弃。 <br>
        问题：网络开销 <br>
        优化:使用limit，在服务端过滤掉数据 <br>

    2. case 2:

        描述：多表关联返回全部的列 || 查询返回不必要的列
        问题：网络开销
        优化：查询必要的列

    3. case 3:

        描述：重复查询相同的数据
        优化：使用缓存
    
2. 分析过量数据：是否存在扫描额外的数据

    1. case 1

        描述:需要扫描大量的行，只是返回少量的数据
        优化：使用索引

3. 特定类型的优化
    
    1. COUNT()查询：COUNT()指明某个列时统计的时列值的数量，即该列不包含NULL的数量。COUNT(*)统计的是行数。
    2.  关联查询优化：

        1. ON || USING 子句的列上有索引。除非有其他理由，否者在关联的第二个表上加上索引便可
        2. 确保任何的GROUP BY || ORDER BY 中的表达式只涉及到一个表中的列，这样索引才会起作用

    3. 子查询优化
    4. 优化GROUP　BY || DISTINCT

        １.　利用索引避免临时表或文件排序
        
##### 服务器优化
1. CPU选择

    OLAP CPU密集型应用
    OLTP IO密集型应用

2. 内存选择
    
    mysql的Innnodb Buffer Pool的命中率

3. 磁盘选择
