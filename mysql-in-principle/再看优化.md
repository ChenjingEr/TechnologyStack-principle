## 优化

#### 数据类型
* 数据类型选择优化：
    - 占用空间更小的数据类型：占用的空间更小，那么存储的内存更小，处理时使用的CPU周期更小，磁盘占用更小。
    - NULL值的考虑：通常情况下，对于NULL的值的处理更加复杂。索引记录需要一个额外的字节
* 具体类型选择：
    - 整数类型：
        + 取值范围与占用的字节数的考虑。选择适用的最小字节的类型
        + 同样类型,sigined & unsigned存储占用空间，性能一致。差别在于unsigned的取值范围是signed的2倍
    - 实数类型(带小数的值):
        + 非精度计算(FLOAT & DOUBLE)&精度计算(DECIMAL)的差别
    - 字符串类型：
        + CHAR：定长存储，适合用于平均长度差不多一致，且更新次数较频繁的值
        + VARCHAR：变成存储，还需要1个或2个额外的字节存储字符的长度。更新变长字符串的列操作不同引擎的处理不同。但是可能会存在分页的风险(更新之后的值比原来的值更长，当前页没有空间的情况下)。适合平均长度参差不齐且变更不是很频繁的情况。
    - 日期类型：
        + TIMESTAMP ＆ DATEDTIME的选择比较。TIMESTAMP占用４字节，与时区有关，且列not null.
    - ENUM:适合存储有固定值集合的数据。内存存储的是数字类型，用数字-字符串映射关系查找。加入新的集合值会引起alter table的操作。取值/比较的过程会需要数字-字符串的转换。

#### schema

#### 索引
* 高性能索引策略
    - 单独的列，使用索引的列不可用作参数或参与计算
    - 复合的索引，使用最左匹配，直到到右侧的第一个范围查询。考虑多列索引的顺序，以及是否要作为一个覆盖索引。考虑查找与排序。
    - TODO

#### SQL优化

* 查询执行的路径
    - 客户端发送sql给服务端
    - 服务器查询缓存，命中则直接返回结果
    - 服务器对SQL解析(语法解析)，预处理(检查解析树是否合法。表，列是否存在等)，再有优化器生成对应的执行计划
    - MYSQL根据优化器生成的执行计划，调用存储引擎API来执行查询
    - 返回结果客户端
* 慢查询分析逻辑：
慢查询的sql中是否有额外的操作，某些操作是否重复，某些操作执行太慢?  <br>
慢查询中的数据访问①是否检索超过需要的数据(太多行，太多列)？②是否分析了大量的不必要的行？
```
1. 是否检索超过需要的数据 -> 客户端向数据库请求了不需要的数据
    * 查询不需要的记录：查询所有的记录，然后在应用程序中取需要的行。使用limit
    * 多表关联时返回全部列:select * ... left join ...。select 需要的列
    * 总是取出所有的列:select * ... 。select 需要的列
2. 是否分析超过需要的数据 -> 扫描之后剩下的数据。索引对查询的优化在于，索引可以让服务器以最高效，扫描最少的方式找到需要的记录。 所以索引是优化的一个关键。 
    sql中where的应用:(快到慢) 
    1. 在索引中使用where，存储引擎层完成。返回给服务层时以及完成了过滤
    2. 使用覆盖索引扫描，返回记录直接在所有中过滤层。服务层完成，这时不需要再扫描聚簇索引。（Extra:Using index）
    3. 普通的where过滤(Using where)
```

* 慢查询重构逻辑：
    - 复杂查询/简单查询：复杂查询可能一次需要锁定更多的行
    - 切分查询：将一个大操作切分成很多个小操作。所有小操作的结果之和与大操作的结果是一致的。大操作需要锁定的行更多
    - 分解关联查询：join分为多次简单查询，然后在应用程序中关联。
        + 让缓存更加有效率，对简单表查询的缓存
        + 减少锁的竞争
        + 然后冗余数据的查询。就join过程中可能需要反复查询一行数据匹配

#### 分区表
分区表用于解决超大的表操作的性能问题。超大的表不可加载入内存且扫描需要极大的消耗。


    





