## mongodb复制

单机存储数据一旦出现单机故障便可能找成数据丢失。monogdb提供复制功能。secondary向primary同步数据实现数据备份。默认情况下，读写请求都发向primary。

**1. primary/secondary各节点通信: ** mongodb中各个节点需要知道其他的状态。哪个是主节点？哪个可以作为同步源？哪个节点挂掉了？<br>
    mongodb中通过每2秒1次的频率向其他节点发送心跳请求(heartbeat request)。心跳请求用于检查每个成员的状态。<br>
    mongodb中节点的状态：

        STARTUP: 节点刚启动，在该节点加载配置信息，完成载入后状态改成STARTUP2 
        STARTUP2: 该过程执行初始化同步。在该阶段，创建线程用于处理复制和选举。完成这些操作后转到RECOVERING
        RECOVERING：节点正常运行，但是还需要做一些检查以确保有效，之后才会处理读取请求
        ARBITER：正常操作。仲裁者节点应该始终处于这个状态。
        -------------------------------------其他状态--------------------------------------------------
        DOWN：节点不可达
        UNKNOWN：其他节点将不可达节点标记为UNKNOWN
        REMOVED：被移除
        ROLLBACK：数据回滚
        FATAL：节点产生不可恢复的错误

**2. 复制:**<br>
mongodb的复制是通过主节点的local.oplog.rs(固定大小，满了会删除最旧记录插入新记录，而且只支持append操作)的文档。主节点会将每次的写操作都记录到oplog.rs中，secondary通过查询local.oplog中的记录来实现同步。每个备份节点都记录一份oplog，这样就可以知道主备节点复制的进度。 <br>    
   
备份节点启动时需要先**初始化同步**再然后通过oplog备份。初始化同步会尝试从一个副本中进行完成的数据复制。初始化同步步骤：
        
1. 选择一个成员作为同步源，在local.me中创建标识，删除所有已存在的数据库。
2. 克隆,将同步源的所有数据都复制到本地，同时将所有操作记录都记录到oplog中。这是一个耗时的操作，如果在这个过程中有些文档被移动，就需要将这部分文档重新克隆
3. 记录重新克隆的oplog
4. 创建索引
5. 将“脱节”部分全部同步
6. 完成初始化同步，切换到普通同步状态

如果一个节点的数据脱节太多的数据，节点会试着在所有的节点中找一个可以复制的同步源，如果找不到(oplog是一个固定集合，集合满时会覆盖掉最早的操作)就需要重新进行完全同步

**3. 故障检测(主节点失效)**<br>


**4. 故障恢复(备份节点选举)**

当其中一个备份节点到主节点不可达，就会申请成为主节点：<br>
可以成为主节点的条件：

1. 主节点确实不可达(主节点不可达可能的原因有主节点宕机/主节点网络问题/备份节点网络问题)
2. majority中的节点都赞成
3. 备份节点的数据是最新的(其他节点发现其节点的数据不是最新的也会拒绝)
4. 没有其他主节点

在副本集的配置中有majority这个概念，但是如果仅仅是2个备份节点，majority就不适用。这是一种解决方案是引入**选举仲裁者**
。仲裁者仅仅是为了选举存在，不复制数据。整个副本集仅可以存在一个仲裁者。

选举过程：
    
    理想的情况下：2秒中之内检查主节点(心跳检测每2秒1次的频率)不可达，选举开始且在几毫秒之内完成
    实际情况：与网络情况，系统负载等因素有关。整个过程可能持续几分钟。


**4. 回滚**

存在这样一种场景，当主节点完成了某一个写入操作但是还没有来得及进行同步就不可达。选举出来的新节点没有同步到前主节点的最后写入操作。当前主节点恢复成为其中一个副本，其中没有写入的操作会进入回滚过程。恢复的节点会寻找共同的操作点，在操纵点之后的操作进行回滚。

回滚并不是直接将数据删除，而是将需要回滚的文档写入一个.bson文件中，保存在rollback目录下。这些数据的处置取决于人，手动恢复或者不予理会。
