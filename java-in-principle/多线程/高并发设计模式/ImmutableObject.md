## ImmutableObject(不可变对象)模式

问题：对共享变量的访问同步控制需要通过锁，或者CAS等方法，这保证了同步的同时却也引入了一些额外的开销问题。锁的上下文切换，CAS的ABA问题， 锁等待等<br>

意图：通过使用对外可见的状态不可变对象，使得被共享对象具有天生的线程安全性，而无须额外地同步访问控制。 <br>

实现概念：建模时将可变的对象转为不可变对象，通过创建不同的状态不可变对象来反应状态变更。 <br>

涉及的对象:不可变对象(维护不可变实例，提供不可变状态的访问方法)，操作对象(用于更改状态变量，这里指的是重新创建一个不可变对象来表示更新) <br>

    不可变对象:

        * class 是final修饰的，避免子类修改
        * 所有的域是final的，JMM提供的内存语义保证final域正确被初始化后再引用。需要防止this的逸出问题

评价：

优势：
    * 在不使用锁的情况下保证线程的安全访问。避免锁，CAS的额外开销和ABA问题 <br>
限制：
    * 不可变对象不可频繁变化(这样需要建立很多个不可变对象)
    * 防御性赋值：如果不可变对象本身包含一些状态需要对外暴露，而相应的字段本身又是可变的，那么返回这些字段的方法还是需要做防御复制，避免外部代码修改了内部状态。

CopyOnWriteArrayList 应用了Immutable Object模式，对CopyOnWriteArrayList的实例进行遍历时不需要加锁
