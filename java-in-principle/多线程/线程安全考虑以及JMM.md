

#### Java内存模型是什么？
Java内存模型(JMM)是Java虚拟机是对主内存与缓存或寄存器的访问规则的抽象。<br>
共享变量(实例域，静态域，数组元素)是放在主内存中，线程访问通过主内存读到线程私有的本地内存(缓存机制) <br>
Java线程间的通信是基于共享内存(另一种是消息通信)，一个线程对共享变量做了修改，另外一个线程读取修改后的变量，完成隐式的通信过程。这种通信模式下的同步 <br>

#### 正确同步需要保证的原子性，可见性，有序性

原子性：整个操作不可中断。一个操作一旦开始就不会被其他线程干扰。(多线程环境下执行同一份代码的干扰) <br>
可见性：一个线程对一个共享变量的修改能够立即被其他线程看见。(缓存或重排序导致的不可见问题) <br>
顺序性：所有的线程都只能看到一个单一的操作执行顺序

#### 重排序(导致的不可见，顺序问题)
重排序是编译器或处理器为程序性能做的优化。重排序的结果可能导致代码的执行顺序与源码编写的顺序不同，没有使用正确的同步保证可见性或顺序性，同步环境下的工作就会产生意料之外的结果。 <br>

```
public class InstructorResort {

    private static boolean flag = true;
    private static int number;
    
    public void fun1() {
        flag = false;     (1)
        number = 2;       (2)
    }
    
    public void fun2() {
        while(flag) {    (3)
            
        }
        
        System.out.println(number); (4)
    }
}
```
这个程序在多线程环境下(A运行fun1, B运行fun2)可能产生的结果:
1. while一直循环 (意料之外结果) 
2.  循环结束，执行输出
3. 输出的数值 = 2  
4. 输出的数值 = 0  (意料之外结果) 

(1)(2)执行没有依赖性，所以重排序的结果可能2在前。while一直循环的原因是没有读到flase的值。读入的是初始化的ture值。输出的number=0是因为没有读到number更新后的值。<font color="#D98880">重排序考虑只是单个线程的数据依赖性，不考虑不同线程间的数据依赖性</font> <br>

重排序从编译一直到被执行，经历编译重排序，指令级并行重排序，内存系统重排序。 <br>
编译器优化重排序：在不改变单线程的语义下，重新排序语句的执行顺序 <br>
指令级并行重排序：指令级并行技术来将多条执行重叠执行
内存系统重排序：处理器使用缓存和读/写缓冲区，是的加载和内存操作看上去是乱序的

并不是所有的重排序都是被允许的，遵循happens-before规则(声明一些规则禁止重排序以保证程序正确执行)：
1. 重排序遵循单线程串行语义
2. volatile规则：volatile写先发生于读，
3. 锁规则:unlock先发生于之后的lock操作
4. 传递性

#### 实现禁止重排序方法：内存屏障
通过Java编译器插入特定的内存屏障来禁止重排序,内存屏障的类型：
LoadLoad Barriers <br>
StoreStore Barriers <br>
LoadStore Barriers <br>
StoreLoad Barriers <br>