### Java同步相关的底层实现原理
####volatile
---
**volatile是什么？**是保证“可见性”的关键字。可见性即一个线程对一个共享变量的修改另一个线程可以读到这个修改。</br>
**底层如何保证可见性？**volatile操作进行写操作会插入Lock前缀指令。Lock前缀指令会执行:</br>

1. 将当前处理器缓存行的数据写回到系统内存</br>
2. 使其他缓存无效（缓存一致性）

**volatile内存语义** </br>
volatile变量自身的特性：

* 可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入
* 原子性。对任意单个volatile变量的读/写具有原子性，但是复合操作(i++)不具有原子性

volatile 写-读 happens-before原则：对一个volatile变量的写，happens-before对这个变量的读。</br>
volatile 写-读 内存语义：当写一个volatile变量，JMM会把该线程对应的本地内存共享变量值刷新到内存。读一个volatile变量时，JMM把该线程的对应的本地内存置为无效</br>
volatiel 内存语义实现：内存屏障

####synchronized
---
**synchrnozed底层实现** JVM用Monitor实现同步，再同步开始与结束处分别插入monitorenter,monitorexist指令</br>
**锁存在哪里?** 对象头的Mark Word标识了锁状态，以及是否是偏向锁状态</br>
**JDK1.6 synchrnozed优化** 为实现优化，将锁分等级，偏向锁，轻量级锁，重量级锁。锁只可升级不可降级</br>

1. 偏向锁：</br>
```
获取锁的过程：
	1. 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。
	2. 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。
	3. 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。
	4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。
　	5. 执行同步代码。
锁的释放过程：
	当下一次锁请求时才开始释放
```
２. 轻量级锁：<br>
```
获取锁的过程：
	1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。
	2. 拷贝对象头中的Mark Word复制到锁记录中。
	3. 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。
	4. 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态
	5. 如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。
解锁过程：
	1. 通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。
	2. 如果替换成功，整个同步过程就完成了。
	3.如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。
```


####原子操作实现
Java中的原子操作实现方式是循环CAS。这种方式存在的问题：

1. ABA
2. 消耗CPU
3. 只可以对一个变量做原子操作

---

###Java内存模型
